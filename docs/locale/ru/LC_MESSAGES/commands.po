# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, MrDandycorn
# This file is distributed under the same license as the vk-botting package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: vk-botting 0.5.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-01-18 02:43+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

# 9c4478c1d33442c08b4c93b36e56b28c
#: ../../commands.rst:6
msgid "Commands"
msgstr ""

# a3fb717a7d934c0581a969416dcc052f
#: ../../commands.rst:8
msgid ""
"One of the most appealing aspect of the command extension is how easy it "
"is to define commands and how you can arbitrarily nest groups and "
"commands to have a rich sub-command system."
msgstr ""

# 1e19663e4b90465db5b1b61b85cbea77
#: ../../commands.rst:11
msgid ""
"Commands are defined by attaching it to a regular Python function. The "
"command is then invoked by the user using a similar signature to the "
"Python function."
msgstr ""

# 9331bba925f746e0aac5219c957568d7
#: ../../commands.rst:14
msgid "For example, in the given command definition:"
msgstr ""

# c52a9cb3e7d849a1ab84b34d03fcef0b
#: ../../commands.rst:22
msgid "With the following prefix (``$``), it would be invoked by the user via:"
msgstr ""

# 15ca9b4612f849849d84b5e255fc518d
#: ../../commands.rst:28
msgid ""
"A command must always have at least one parameter, ``ctx``, which is the "
":class:`.Context` as the first one."
msgstr ""

# 4ae85d6fab4d43f2a3b9f10dd65bcffa
#: ../../commands.rst:30
msgid ""
"There are two ways of registering a command. The first one is by using "
":meth:`.Bot.command` decorator, as seen in the example above. The second "
"is using the :func:`~ext.commands.command` decorator followed by "
":meth:`.Bot.add_command` on the instance."
msgstr ""

# 90ccbd9747c74cd7a7a4811e946d20e2
#: ../../commands.rst:34
msgid "Essentially, these two are equivalent: ::"
msgstr ""

# c7da394255d645bd90dd8720435c86e5
#: ../../commands.rst:52
msgid ""
"Since the :meth:`.Bot.command` decorator is shorter and easier to "
"comprehend, it will be the one used throughout the documentation here."
msgstr ""

# 112033f26a7f4fb7a14d6b36555e4866
#: ../../commands.rst:55
msgid ""
"Any parameter that is accepted by the :class:`.Command` constructor can "
"be passed into the decorator. For example, to change the name to "
"something other than the function would be as simple as doing this:"
msgstr ""

# 7f8a49ddfa754320993cd62e8ccc7fab
#: ../../commands.rst:65
msgid "Parameters"
msgstr ""

# 899f8ec1f0254cbcab49faa51d4ae0cf
#: ../../commands.rst:67
msgid ""
"Since we define commands by making Python functions, we also define the "
"argument passing behaviour by the function parameters."
msgstr ""

# e498c58bb318451cb1dd1ae66c9cd990
#: ../../commands.rst:70
msgid ""
"Certain parameter types do different things in the user side and most "
"forms of parameter types are supported."
msgstr ""

# ca4419b24550433caec597f7cecb8977
#: ../../commands.rst:73
msgid "Positional"
msgstr ""

# ed904bb945dc41c3a21d6fa5c4d3cf5f
#: ../../commands.rst:75
msgid ""
"The most basic form of parameter passing is the positional parameter. "
"This is where we pass a parameter as-is:"
msgstr ""

# 3c93b8c089a44accabe45f537c6f0601
#: ../../commands.rst:84
msgid ""
"On the bot using side, you can provide positional arguments by just "
"passing a regular string:"
msgstr ""

# 9d8e8774f374417a808674d994e26403
#: ../../commands.rst:86
msgid ""
"Since positional arguments are just regular Python arguments, you can "
"have as many as you want:"
msgstr ""

# b89b92117eeb4879837de5bd6c8e4d27
#: ../../commands.rst:95
msgid "Variable"
msgstr ""

# a249675be5a2442891f7e62d3ae9b332
#: ../../commands.rst:97
msgid ""
"Sometimes you want users to pass in an undetermined number of parameters."
" The library supports this similar to how variable list parameters are "
"done in Python:"
msgstr ""

# 3a0fda2781224e04abe20a4c54c87767
#: ../../commands.rst:106
msgid ""
"This allows our user to accept either one or many arguments as they "
"please."
msgstr ""

# 083ee55ddf044a2288ec7806d50b722b
#: ../../commands.rst:108
msgid ""
"Do note that similar to the Python function behaviour, a user can "
"technically pass no arguments at all."
msgstr ""

# e5cc5ada5b8a4342bdccb5ff6b8cea55
#: ../../commands.rst:111
msgid ""
"Since the ``args`` variable is a :class:`py:tuple`, you can do anything "
"you would usually do with one."
msgstr ""

# 75e94216589e41e98bdde61e245affd1
#: ../../commands.rst:115
msgid "Keyword-Only Arguments"
msgstr ""

# e3f316f29a5e4e9eb9c58ea257e8bd49
#: ../../commands.rst:117
msgid ""
"When you want to handle parsing of the argument yourself or do not feel "
"like you want to wrap multi-word user input into quotes, you can ask the "
"library to give you the rest as a single argument. We do this by using a "
"**keyword-only argument**, seen below:"
msgstr ""

# 2ab00799c48e4a0b92ebb09fef7674da
#: ../../commands.rst:129
msgid "You can only have one keyword-only argument due to parsing ambiguities."
msgstr ""

# 9bf787f9179b40748e18199ad5167613
#: ../../commands.rst:131
msgid ""
"By default, the keyword-only arguments are stripped of white space to "
"make it easier to work with. This behaviour can be toggled by the "
":attr:`.Command.rest_is_raw` argument in the decorator."
msgstr ""

# 876a799b72f246f2baaf360997492614
#: ../../commands.rst:137
msgid "Invocation Context"
msgstr ""

# d9a994a9678b46cc89311ceaf8f1acc3
#: ../../commands.rst:139
msgid ""
"As seen earlier, every command must take at least a single parameter, "
"called the :class:`context.Context`."
msgstr ""

# 332d4e80f96f44a3bd3a1d1f95c88980
#: ../../commands.rst:141
msgid ""
"This parameter gives you access to something called the \"invocation "
"context\". Essentially all the information you need to know how the "
"command was executed. It contains a lot of useful information:"
msgstr ""

# 9467185274794cd6bb59cdd242265126
#: ../../commands.rst:144
msgid ":attr:`.Context.from_id` to fetch the id of message author."
msgstr ""

# f1cce2687cb2456cbaa2e625ddc4eb59
#: ../../commands.rst:145
msgid ":attr:`.Context.peer_id` to fetch id of conversation."
msgstr ""

# f7f68304f9b840d6a221c2dc5a476451
#: ../../commands.rst:146
msgid ""
":meth:`.Context.get_user` to fetch the :class:`User` that called the "
"command."
msgstr ""

# 940472227e734ebab87487811e3355b2
#: ../../commands.rst:147
msgid ""
":meth:`.Context.send` to send a message to the conversation the command "
"was used in."
msgstr ""

# fc4e3edcfee24b359a34f1bbf8622858
#: ../../commands.rst:149
msgid ""
"The context implements the :class:`abstract.Messageable` interface, so "
"anything you can do on a :class:`abstract.Messageable` you can do on the "
":class:`context.Context`."
msgstr ""

# e438cf54de874470acb15570427b734d
#: ../../commands.rst:153
msgid "Converters"
msgstr ""

# e8fa1d491a7a4834a3a310b35cc9bb82
#: ../../commands.rst:155
msgid ""
"Adding bot arguments with function parameters is only the first step in "
"defining your bot's command interface. To actually make use of the "
"arguments, we usually want to convert the data into a target type. We "
"call these Converters."
msgstr ""

# 2c4c482953534985b1fc456abc125f86
#: ../../commands.rst:159
msgid "Converters come in a few flavours:"
msgstr ""

# d30a6ec476ab4d249113fb648b2dbf5e
#: ../../commands.rst:161
msgid ""
"A regular callable object that takes an argument as a sole parameter and "
"returns a different type."
msgstr ""

# 896d8a073d134f2a9e5eb1de0967b74b
#: ../../commands.rst:163
msgid ""
"These range from your own function, to something like :class:`bool` or "
":class:`int`."
msgstr ""

# de31920704284885ab089690e796898d
#: ../../commands.rst:165
msgid "A custom class that inherits from :class:`conversions.Converter`."
msgstr ""

# d096a74fb2b147cf9ab85f7ad99da031
#: ../../commands.rst:168
msgid "Basic Converters"
msgstr ""

# 1efd4fe958414e4f96478fdf8a4bb1c6
#: ../../commands.rst:170
msgid ""
"At its core, a basic converter is a callable that takes in an argument "
"and turns it into something else."
msgstr ""

# e2945899eff94e42893927532b9942d5
#: ../../commands.rst:172
msgid ""
"For example, if we wanted to add two numbers together, we could request "
"that they are turned into integers for us by specifying the converter:"
msgstr ""

# a12a5abfae0043b5859fb6426e22b12e
#: ../../commands.rst:181
msgid ""
"We specify converters by using something called a **function "
"annotation**. This is a Python 3 exclusive feature that was introduced in"
" :pep:`3107`."
msgstr ""

# ad0deb5e9ff8445aae529b2d3b7aad9a
#: ../../commands.rst:184
msgid ""
"This works with any callable, such as a function that would convert a "
"string to all upper-case:"
msgstr ""

# feaa6c0c91604de4bc6b90d909efabca
#: ../../commands.rst:196
msgid "bool"
msgstr ""

# 91587fe2c9ad462b822628a749e1e88d
#: ../../commands.rst:198
msgid ""
"Unlike the other basic converters, the :class:`bool` converter is treated"
" slightly different. Instead of casting directly to the :class:`bool` "
"type, which would result in any non-empty argument returning ``True``, it"
" instead evaluates the argument as ``True`` or ``False`` based on its "
"given content:"
msgstr ""

# 7e5f0002f5e74607a0f3e947b178af56
#: ../../commands.rst:210
msgid "Advanced Converters"
msgstr ""

# ef66e7b19d894c3caf286605fd0e0099
#: ../../commands.rst:212
msgid ""
"Sometimes a basic converter doesn't have enough information that we need."
" For example, sometimes we want to get some information from the "
":class:`Message` that called the command or we want to do some "
"asynchronous processing."
msgstr ""

# e4c7fa46d16649949373acf689f29b2b
#: ../../commands.rst:215
msgid ""
"For this, the library provides the :class:`conversions.Converter` "
"interface. This allows you to have access to the :class:`.Context` and "
"have the callable be asynchronous. Defining a custom converter using this"
" interface requires overriding a single method, "
":meth:`.Converter.convert`."
msgstr ""

# 5ea74b9995714721994b7660d6001dfa
#: ../../commands.rst:219
msgid "An example converter:"
msgstr ""

# 59c80b0511a34844ac4dc0605c984403
#: ../../commands.rst:234
msgid ""
"The converter provided can either be constructed or not. Essentially "
"these two are equivalent:"
msgstr ""

# 75c4cee8cd824669acc33175cea4f095
#: ../../commands.rst:248
msgid ""
"Having the possibility of the converter be constructed allows you to set "
"up some state in the converter's ``__init__`` for fine tuning the "
"converter."
msgstr ""

# fb8a3cedfa384fa5827c64f9087b6107
#: ../../commands.rst:251
msgid ""
"If a converter fails to convert an argument to its designated target "
"type, the :exc:`.BadArgument` exception must be raised."
msgstr ""

# 3ef5838c606c43129d56489d00a2cd00
#: ../../commands.rst:258
msgid "Error Handling"
msgstr ""

# 68b42f3d2c8f4baea476ee9c88311b95
#: ../../commands.rst:260
msgid ""
"When our commands fail to parse we will, by default, receive a noisy "
"error in ``stderr`` of our console that tells us that an error has "
"happened and has been silently ignored."
msgstr ""

# b948f43a1e914a2b916c52244ab8eb4f
#: ../../commands.rst:263
msgid ""
"In order to handle our errors, we must use something called an error "
"handler. There is a global error handler, called :func:`on_command_error`"
" which works like any other event in the :ref:`vk_api_events`. This "
"global error handler is called for every error reached."
msgstr ""

# a2e9906fed504cd39334787baae7091f
#: ../../commands.rst:267
msgid ""
"Most of the time however, we want to handle an error local to the command"
" itself. Luckily, commands come with local error handlers that allow us "
"to do just that. First we decorate an error handler function with "
":meth:`.Command.error`:"
msgstr ""

# cebe44e1a1d14901a6c4d44188d8e35a
#: ../../commands.rst:284
msgid ""
"The first parameter of the error handler is the :class:`.Context` while "
"the second one is an exception that is derived from "
":exc:`exceptions.CommandError`. A list of errors is found in the "
":ref:`vk_api_errors` page of the documentation."
msgstr ""

# 8fcdc74870d3483895b42b8077cc918f
#: ../../commands.rst:288
msgid "Checks"
msgstr ""

# 1a47bea45cda414cb82eb1f5357749ac
#: ../../commands.rst:290
msgid ""
"There are cases when we don't want a user to use our commands. They don't"
" have permissions to do so or maybe we blocked them from using our bot "
"earlier. The commands extension comes with full support for these things "
"in a concept called a check."
msgstr ""

# c10b4be157b54aa3a7002cfa1b16a3e0
#: ../../commands.rst:293
msgid ""
"A check is a basic predicate that can take in a :class:`.Context` as its "
"sole parameter. Within it, you have the following options:"
msgstr ""

# 3ee50b1861b2443b96590e4f944cad38
#: ../../commands.rst:296
msgid "Return ``True`` to signal that the person can run the command."
msgstr ""

# b3cf4867f9fb42ad97f61fd454298eee
#: ../../commands.rst:297
msgid "Return ``False`` to signal that the person cannot run the command."
msgstr ""

# 2b85494f0e0c41bc8864060589dd9f51
#: ../../commands.rst:298
msgid ""
"Raise a :exc:`exceptions.CommandError` derived exception to signal the "
"person cannot run the command."
msgstr ""

# 84d9ffddc62a459291ca960b6ae417f0
#: ../../commands.rst:300
msgid ""
"This allows you to have custom error messages for you to handle in the "
":ref:`error handlers <vk_api_error_handler>`."
msgstr ""

# f4dbf12d29ef4256afbee313340973e6
#: ../../commands.rst:303
msgid ""
"To register a check for a command, we would have two ways of doing so. "
"The first is using the :meth:`limiters.check` decorator. For example:"
msgstr ""

# fae7467fa7ef41a887eae05371119c79
#: ../../commands.rst:317
msgid ""
"This would only evaluate the command if the function ``is_owner`` returns"
" ``True``. Sometimes we re-use a check often and want to split it into "
"its own decorator. To do that we can just add another level of depth:"
msgstr ""

# 61a9ccdded094e6e8ff2faa039ed3a7e
#: ../../commands.rst:334
msgid ""
"Library actually provides a premade check to check if user is in given "
"list (:func:`limitest.in_user_list`):"
msgstr ""

# a4f278186c3d4639aeabef2b19a40aea
#: ../../commands.rst:344
msgid "When multiple checks are specified, **all** of them must be ``True``:"
msgstr ""

# 10c78b1f17c64e8083b849e90b96959a
#: ../../commands.rst:360
msgid ""
"If any of those checks fail in the example above, then the command will "
"not be run."
msgstr ""

# 12e450f17d5c4897b473fe4d286ab7ce
#: ../../commands.rst:362
msgid ""
"When an error happens, the error is propagated to the :ref:`error "
"handlers <vk_api_error_handler>`. If you do not raise a custom "
":exc:`exceptions.CommandError` derived exception, then it will get "
"wrapped up into a :exc:`exceptions.CheckFailure` exception as so:"
msgstr ""

# 688292965482497bb1f520549320491f
#: ../../commands.rst:381
msgid "Global Checks"
msgstr ""

# e2499cce0bb2466ea2a590757d20d744
#: ../../commands.rst:383
msgid ""
"Sometimes we want to apply a check to **every** command, not just certain"
" commands. The library supports this as well using the global check "
"concept."
msgstr ""

# 515a0e314c434e7abc435b8499001422
#: ../../commands.rst:386
msgid ""
"Global checks work similarly to regular checks except they are registered"
" with the :func:`.Bot.check` decorator."
msgstr ""

# a1153ef5324149d481c32404c8dd5c77
#: ../../commands.rst:388
msgid "For example, to block all DMs we could do the following:"
msgstr ""

# fdbcf0e2223d4789897af82c087c5915
#: ../../commands.rst:398
msgid ""
"Be careful on how you write your global checks, as it could also lock you"
" out of your own bot."
msgstr ""

